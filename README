Exercise 4: LCD

Assessment Description

Liquid Crystal Displays

This week's test is to write a program that displays LCD style hexadecimal numbers at adjustable sizes. The hexadecimal digits to be displayed will be passed as an argument to the program. The default value for the digits’ size is 1. For example, if the display() method is called with:

> display(“1234567890ABCDEF”)
The correct display is:

      -   -       -   -   -   -   -   -   -   -   -       -   -  
   |   |   | | | |   |     | | | | | | | | | | | |     | |   |   
      -   -   -   -   -       -   -   /   -  |=       -   -   -  
   | |     |   |   | | |   | | |   | | | | | | | |   | | |   |   
      -   -       -   -       -   -   -       -   -   -   -      
Note the single column of space between the hexadecimal digits and the lowercase‘d’ in the example.

Below part of the code for lcd.rb is already implemented. Your task is to produce the code for the display() method. This method is passed the digits to be displayed.

class LCD
       attr_accessor( :size, :spacing )

       #
       # This hash is used to define the segment display for the
       # given digit. Each entry in the array is associated with
       # the following states:
       #
       #    HORIZONTAL
       #    VERTICAL
       #    HORIZONTAL
       #    VERTICAL
       #    HORIZONTAL
       #    DONE
       #
       # The HORIZONTAL state produces a single horizontal line. There
       # are two types:
       #
       #    0 - skip, no line necessary, just space fill
       #    1 - line required of given size
       #
       # The VERTICAL state produces a either a single right side line,
       # a single left side line or a both lines.
       #
       #    0 - skip, no line necessary, just space fill
       #    1 - single right side line
       #    2 - single left side line
       #    3 - both lines
       #
       # The DONE state terminates the state machine. This is not needed
       # as part of the data array.
       #
       @@lcdDisplayData = {
	    "0" => [ 1, 3, 3, 3, 1 ],
	    "1" => [ 0, 1, 0, 1, 0 ],
	    "2" => [ 1, 1, 1, 2, 1 ],
	    "3" => [ 1, 1, 1, 1, 1 ],
	    "4" => [ 0, 3, 1, 1, 0 ],
	    "5" => [ 1, 2, 1, 1, 1 ],
	    "6" => [ 1, 2, 1, 3, 1 ],
	    "7" => [ 1, 1, 0, 1, 0 ],
	    "8" => [ 1, 3, 1, 3, 1 ],
	    "9" => [ 1, 3, 1, 1, 1 ],
	    "A" => [ 1, 3, 1, 3, 0 ],
	    "B" => [ 1, 3, 2, 3, 1 ],
	    "C" => [ 1, 2, 0, 2, 1 ],
	    "D" => [ 0, 1, 1, 3, 1 ],
	    "E" => [ 1, 2, 1, 2, 1 ],
	    "F" => [ 1, 2, 1, 2, 0 ],
       }

       @@lcdStates = [
           "HORIZONTAL",
           "VERTICAL",
           "HORIZONTAL",
           "VERTICAL",
           "HORIZONTAL",
           "DONE"
       ]

       def initialize( size=1, spacing=1 )
           @size = size
           @spacing = spacing
       end

       def display( digits )

	# CODE GOES HERE!
       end

    end

    d = LCD.new(1, 1, "")
    d.display("12")

Hint

A strategy you can use is based on a class which represents a state machine. For the needed size (set in initialize()), that class walks a series of states (defined in @@lcdStates). At each state, horizontal and vertical segments are built as needed (with horizontal_segment() and vertical_segment()). The process just described is run through display(), the primary interface method. You pass it a string of digits, it walks each state, and generates segments as needed. One nice aspect of this approach is that it's easy to handle output one line at a time and display() does this. The top line of all digits, generated by the first "HORIZONTAL" state, is printed as soon as it's built, as is each state that follows. This resource friendly system could scale well to much larger inputs.